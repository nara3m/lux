.\" Automatically generated by Pod::Man 2.22 (Pod::Simple 3.07)
.\"
.\" Standard preamble:
.\" ========================================================================
.de Sp \" Vertical space (when we can't use .PP)
.if t .sp .5v
.if n .sp
..
.de Vb \" Begin verbatim text
.ft CW
.nf
.ne \\$1
..
.de Ve \" End verbatim text
.ft R
.fi
..
.\" Set up some character translations and predefined strings.  \*(-- will
.\" give an unbreakable dash, \*(PI will give pi, \*(L" will give a left
.\" double quote, and \*(R" will give a right double quote.  \*(C+ will
.\" give a nicer C++.  Capital omega is used to do unbreakable dashes and
.\" therefore won't be available.  \*(C` and \*(C' expand to `' in nroff,
.\" nothing in troff, for use with C<>.
.tr \(*W-
.ds C+ C\v'-.1v'\h'-1p'\s-2+\h'-1p'+\s0\v'.1v'\h'-1p'
.ie n \{\
.    ds -- \(*W-
.    ds PI pi
.    if (\n(.H=4u)&(1m=24u) .ds -- \(*W\h'-12u'\(*W\h'-12u'-\" diablo 10 pitch
.    if (\n(.H=4u)&(1m=20u) .ds -- \(*W\h'-12u'\(*W\h'-8u'-\"  diablo 12 pitch
.    ds L" ""
.    ds R" ""
.    ds C` ""
.    ds C' ""
'br\}
.el\{\
.    ds -- \|\(em\|
.    ds PI \(*p
.    ds L" ``
.    ds R" ''
'br\}
.\"
.\" Escape single quotes in literal strings from groff's Unicode transform.
.ie \n(.g .ds Aq \(aq
.el       .ds Aq '
.\"
.\" If the F register is turned on, we'll generate index entries on stderr for
.\" titles (.TH), headers (.SH), subsections (.SS), items (.Ip), and index
.\" entries marked with X<> in POD.  Of course, you'll have to process the
.\" output yourself in some meaningful fashion.
.ie \nF \{\
.    de IX
.    tm Index:\\$1\t\\n%\t"\\$2"
..
.    nr % 0
.    rr F
.\}
.el \{\
.    de IX
..
.\}
.\"
.\" Accent mark definitions (@(#)ms.acc 1.5 88/02/08 SMI; from UCB 4.2).
.\" Fear.  Run.  Save yourself.  No user-serviceable parts.
.    \" fudge factors for nroff and troff
.if n \{\
.    ds #H 0
.    ds #V .8m
.    ds #F .3m
.    ds #[ \f1
.    ds #] \fP
.\}
.if t \{\
.    ds #H ((1u-(\\\\n(.fu%2u))*.13m)
.    ds #V .6m
.    ds #F 0
.    ds #[ \&
.    ds #] \&
.\}
.    \" simple accents for nroff and troff
.if n \{\
.    ds ' \&
.    ds ` \&
.    ds ^ \&
.    ds , \&
.    ds ~ ~
.    ds /
.\}
.if t \{\
.    ds ' \\k:\h'-(\\n(.wu*8/10-\*(#H)'\'\h"|\\n:u"
.    ds ` \\k:\h'-(\\n(.wu*8/10-\*(#H)'\`\h'|\\n:u'
.    ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'^\h'|\\n:u'
.    ds , \\k:\h'-(\\n(.wu*8/10)',\h'|\\n:u'
.    ds ~ \\k:\h'-(\\n(.wu-\*(#H-.1m)'~\h'|\\n:u'
.    ds / \\k:\h'-(\\n(.wu*8/10-\*(#H)'\z\(sl\h'|\\n:u'
.\}
.    \" troff and (daisy-wheel) nroff accents
.ds : \\k:\h'-(\\n(.wu*8/10-\*(#H+.1m+\*(#F)'\v'-\*(#V'\z.\h'.2m+\*(#F'.\h'|\\n:u'\v'\*(#V'
.ds 8 \h'\*(#H'\(*b\h'-\*(#H'
.ds o \\k:\h'-(\\n(.wu+\w'\(de'u-\*(#H)/2u'\v'-.3n'\*(#[\z\(de\v'.3n'\h'|\\n:u'\*(#]
.ds d- \h'\*(#H'\(pd\h'-\w'~'u'\v'-.25m'\f2\(hy\fP\v'.25m'\h'-\*(#H'
.ds D- D\\k:\h'-\w'D'u'\v'-.11m'\z\(hy\v'.11m'\h'|\\n:u'
.ds th \*(#[\v'.3m'\s+1I\s-1\v'-.3m'\h'-(\w'I'u*2/3)'\s-1o\s+1\*(#]
.ds Th \*(#[\s+2I\s-2\h'-\w'I'u*3/5'\v'-.3m'o\v'.3m'\*(#]
.ds ae a\h'-(\w'a'u*4/10)'e
.ds Ae A\h'-(\w'A'u*4/10)'E
.    \" corrections for vroff
.if v .ds ~ \\k:\h'-(\\n(.wu*9/10-\*(#H)'\s-2\u~\d\s+2\h'|\\n:u'
.if v .ds ^ \\k:\h'-(\\n(.wu*10/11-\*(#H)'\v'-.4m'^\v'.4m'\h'|\\n:u'
.    \" for low resolution devices (crt and lpr)
.if \n(.H>23 .if \n(.V>19 \
\{\
.    ds : e
.    ds 8 ss
.    ds o a
.    ds d- d\h'-1'\(ga
.    ds D- D\h'-1'\(hy
.    ds th \o'bp'
.    ds Th \o'LP'
.    ds ae ae
.    ds Ae AE
.\}
.rm #[ #] #H #V #F C
.\" ========================================================================
.\"
.IX Title "CHAINABBREV 1"
.TH CHAINABBREV 1 "2012-09-04" "perl v5.10.1" "LipidMAPSTools"
.\" For nroff, turn off justification.  Always turn off hyphenation; it makes
.\" way too many mistakes in technical documents.
.if n .ad l
.nh
.SH "NAME"
ChainAbbrev \- Methods for processing chain abbreviations
.SH "SYNOPSIS"
.IX Header "SYNOPSIS"
use ChainAbbrev;
.PP
use ChainAbbrev qw(:all);
.SH "DESCRIPTION"
.IX Header "DESCRIPTION"
ChainAbbrev module provides these methods:
.PP
.Vb 10
\&    ChainAbbrevNameExists \- Is it a supported chain abbreviation
\&    ExpandChainAbbrev \- Expand wild cards in chain abbreviation
\&    GetChainAbbrevToNameMap \- Get chain name
\&    GetChainLenAbbrevSupportedMap \- Get reference to supported chain
\&                                    abbreviations data
\&    GetChainLenAbbrevDbleBondGeometryDataMap \- Get reference to supported
\&                                               double bond geometry data
\&    GetChainLengthAndMultipleBondCount \- Get chain length and number of
\&                                         double and triple bonds
\&    GetChainLenToNamePrefixMap \- Get chain name prefix
\&    GetCountToNamePrefixMap \- Get count prefix
\&    GetSubstituentsAbbrevToNameMap \- Get substituents name
\&    GetSubstituentBondOrder \- Get substituent bond order
\&    GetSupportedChainLenList \- Get supported chain lengths
\&    IsAlkylChainAbbrev \- Is it a alkyl chain abbreviation
\&    IsAlkenylChainAbbrev \- Is it a alkenyl chain abbreviation
\&    IsChainAbbrevOkay \- Is it a valid chain abbreviation
\&    IsDoubleBondsAbbrevOkay \- Is it a valid double bond abbreviation
\&    IsRingsAbbrevOkay \- Is it a valid ring abbreviation
\&    IsSubstituentsAbbrevOkay \- Is it a valid substituent abbreviation
\&    IsWildCardInChainAbbrev \- Does chain abbreviation contains a wild card
\&    ParseChainAbbrev \- Parse chain abbreviation
\&    ParseRingAbbrev \- Parse ring abbreviation
\&    ParseSubstituentAbbrev \- Parse substituent abbreviation
\&    SetupChainSubstituentsName \- Set up substituent name
.Ve
.SH "METHODS"
.IX Header "METHODS"
.IP "\fBChainAbbrevNameExists\fR" 4
.IX Item "ChainAbbrevNameExists"
.Vb 1
\&    $Status = ChainAbbrevNameExists($ChainAbbrev);
.Ve
.Sp
Return 1 or 0 based on whether it's a supported chain name.
.IP "\fBExpandChainAbbrev\fR" 4
.IX Item "ExpandChainAbbrev"
.Vb 1
\&    $AbbrevArrayRef = ExpandChainAbbrev($Abbrev);
.Ve
.Sp
Return a reference to an array containing complete chain abbreviations. Wild card
characters in chain abbreviation name are expanded to generate fully qualified
chain abbreviations.
.IP "\fBGetChainAbbrevToNameMap\fR" 4
.IX Item "GetChainAbbrevToNameMap"
.Vb 1
\&    $AbbrevNameHashRef = GetChainAbbrevToNameMap();
.Ve
.Sp
Return a reference to hash with chain abbreviation/name as key/value pair.
.IP "\fBGetChainLenAbbrevSupportedMap\fR" 4
.IX Item "GetChainLenAbbrevSupportedMap"
.Vb 1
\&    $ChainLenHashRef = GetChainLenAbbrevSupportedMap();
.Ve
.Sp
Return a reference to hash with supported chain length as hash key.
.IP "\fBGetChainLenAbbrevDbleBondGeometryDataMap\fR" 4
.IX Item "GetChainLenAbbrevDbleBondGeometryDataMap"
.Vb 2
\&    $ChainLenDblBondHashRef =
\&        GetChainLenAbbrevDbleBondGeometryDataMap();
.Ve
.Sp
Return a reference to hash containing information about chain length, number of
double bonds and geometry of double bonds.
.IP "\fBGetChainLengthAndMultipleBondCount\fR" 4
.IX Item "GetChainLengthAndMultipleBondCount"
.Vb 2
\&    ($ChainLength, $DoubleBondCount, $TripleBondCount) =
\&        GetChainLengthAndMultipleBondCount($ChainAbbrev);
.Ve
.Sp
Parse chain abbreviation and return these values: chain length; number of
double and triple bonds.
.IP "\fBGetChainLenToNamePrefixMap\fR" 4
.IX Item "GetChainLenToNamePrefixMap"
.Vb 1
\&    $ChainNameHashRef = GetChainLenToNamePrefixMap();
.Ve
.Sp
Return a reference to hash with chain length/name prefix as key/value pair.
.IP "\fBGetCountToNamePrefixMap\fR" 4
.IX Item "GetCountToNamePrefixMap"
.Vb 1
\&    $CountHashRef = GetCountToNamePrefixMap();
.Ve
.Sp
Return a reference to hash with count/name prefix as key/value pair.
.IP "\fBGetSubstituentsAbbrevToNameMap\fR" 4
.IX Item "GetSubstituentsAbbrevToNameMap"
.Vb 1
\&    $AbbrevNameHashRef = GetSubstituentsAbbrevToNameMap();
.Ve
.Sp
Return a reference to hash with substituents abbreviation/name as key/value pair.
.IP "\fBGetSubstituentBondOrder\fR" 4
.IX Item "GetSubstituentBondOrder"
.Vb 1
\&    $BondOrder = GetSubstituentBondOrder($SubstituentAbbrev);
.Ve
.Sp
Return bond order for a sustituent.
.IP "\fBGetSupportedChainLenList\fR" 4
.IX Item "GetSupportedChainLenList"
.Vb 1
\&    $ChainLengthListRef = GetSupportedChainLenList();
.Ve
.Sp
Return a reference to a sorted list containing supported chain lengths.
.IP "\fBIsAlkylChainAbbrev\fR" 4
.IX Item "IsAlkylChainAbbrev"
.Vb 1
\&    $Status = IsAlkylChainAbbrev($ChainAbbrev);
.Ve
.Sp
Return 1 or 0 based on whether it's a alkyl chain abbreviation.
.IP "\fBIsAlkenylChainAbbrev\fR" 4
.IX Item "IsAlkenylChainAbbrev"
.Vb 1
\&    $Status = IsAlkenylChainAbbrev($ChainAbbrev);
.Ve
.Sp
Return 1 or 0 based on whether it's a alkenyl chain abbreviation.
.IP "\fBIsChainAbbrevOkay\fR" 4
.IX Item "IsChainAbbrevOkay"
.Vb 1
\&    $Status = IsChainAbbrevOkay($ChainAbbrev);
.Ve
.Sp
Return 1 or 0 based on whether chain abbreviation is valid.
.IP "\fBIsDoubleBondsAbbrevOkay\fR" 4
.IX Item "IsDoubleBondsAbbrevOkay"
.Vb 2
\&    $Status = IsDoubleBondsAbbrevOkay($ChainAbbrev, $ChainLength,
\&        $DoubleBondCount, $DoubleBondGeometry);
.Ve
.Sp
Return 1 or 0 based on whether chain abbreviation contains a valid multiple bond specification.
.IP "\fBIsRingsAbbrevOkay\fR" 4
.IX Item "IsRingsAbbrevOkay"
.Vb 1
\&    $Status = IsRingsAbbrevOkay($ChainAbbrev, $ChainLength, $Rings);
.Ve
.Sp
Return 1 or 0 based on whether chain abbreviation contains a valid ring specification.
.IP "\fBIsSubstituentsAbbrevOkay\fR" 4
.IX Item "IsSubstituentsAbbrevOkay"
.Vb 2
\&    $Status = IsSubstituentsAbbrevOkay($ChainAbbrev, $ChainLength,
\&        $DoubleBondCount, $DoubleBondGeometry, $Substituents);
.Ve
.Sp
Return 1 or 0 based on whether chain abbreviation contains a valid substituents specification.
.IP "\fBIsWildCardInChainAbbrev\fR" 4
.IX Item "IsWildCardInChainAbbrev"
.Vb 1
\&    $Status = IsWildCardInChainAbbrev($ChainAbbrev);
.Ve
.Sp
Return 1 or 0 based on whether chain abbreviation contains any wild card character.
.IP "\fBParseChainAbbrev\fR" 4
.IX Item "ParseChainAbbrev"
.Vb 2
\&    ($ChainLength, $DoubleBondCount, $DoubleBondGeometry) =
\&        ParseChainAbbrev($ChainAbbrev);
.Ve
.Sp
Parse chain abbreviation and return these values: chain length, number of double bonds,
and geometry of double bonds.
.IP "\fBParseRingAbbrev\fR" 4
.IX Item "ParseRingAbbrev"
.Vb 1
\&    ($Pos, $StereoChemistry) = ParseRingAbbrev($ChainAbbrev);
.Ve
.Sp
Parse chain abbreviation and return these values: ring position and stereochemistry
specificaton at the ring.
.IP "\fBParseSubstituentAbbrev\fR" 4
.IX Item "ParseSubstituentAbbrev"
.Vb 2
\&    ($Pos, $Name, $StereoChemistry) =
\&        ParseSubstituentAbbrev($SubstituentAbbrev);
.Ve
.Sp
Parse substituent abbreviation and return these values: position of the substituent
on the chain, name, and stereochemistry of the substituent.
.IP "\fBSetupChainSubstituentsName\fR" 4
.IX Item "SetupChainSubstituentsName"
.Vb 2
\&    $SubstituentsName = SetupChainSubstituentsName(
\&        $CmpdAbbrevTemplateDataMapRef, $ChainIndex);
.Ve
.Sp
Return systematic name for substituents after ordering and grouping substituents by their
position.
.SH "AUTHOR"
.IX Header "AUTHOR"
Manish Sud
.SH "CONTRIBUTOR"
.IX Header "CONTRIBUTOR"
Eoin Fahy
.SH "SEE ALSO"
.IX Header "SEE ALSO"
LMAPSStr.pm, ChainStr.pm
.SH "COPYRIGHT"
.IX Header "COPYRIGHT"
Copyright (C) 2006\-2012. The Regents of the University of California. All Rights Reserved.
.SH "LICENSE"
.IX Header "LICENSE"
Modified \s-1BSD\s0 License
